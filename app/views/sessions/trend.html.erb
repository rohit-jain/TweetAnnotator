<html>
<head>
<style type='text/css'>

</style>

<script type="text/javascript">

var BAR_HEIGHT=50;
var topOffset=50;
var BAR_SPEED=3;
var COLOR_STEP=0.01;
var nextColorIndex=0;
var MAX_ANGLE = Math.PI / 32;
var angle = MAX_ANGLE;
var angleAdjust = Math.PI / 3600;

var backgroundImage = new Image();
backgroundImage.src="../../assets/grid.png";

var shootingObject = new Image();
shootingObject.src="../../assets/Tank.gif"

var bulletImg = new Image();
bulletImg.src="../../assets/bullet.png";

var tweetInCloud = new Array();
var cloudShiftY1=0;
var cloudShiftX1=0;
var cloudShiftY2=0;
var cloudShiftX2=0;
var curTwInd=0;
var targetToken="";
var nbullets=0;
var initNbullet=0;
var x,y;
var curTarInd=0;
var tarTwInd=-1;
var tarToken=0;
bulletArray = new Array();

activeColor= new Color(0,0,255);
	
	colors = new Array();
	colors[0]=(new Color(200, 160, 150));
	colors[1]=(new Color(230, 160, 90));
	colors[2]=(new Color(230, 240, 90));
	colors[3]=(new Color(100, 240, 190));
	colors[4]=(new Color(100, 170, 220));
	colors[5]=(new Color(200, 100, 220));

function init(){
	ctx=document.getElementById("backgroundCanvas").getContext('2d');

    <% @currentTweetArray.each do |key|%>
    tweetInCloud.push(new tweetCloud("<%= key.tweetId %>","<%= key.tweetText %>","<%= key.tweetToken1 %>","<%= key.tweetToken2 %>",100,0,60,20,540,20));
    <% end %>
	try{
	drawScene();
	}
	catch(err)
	{
	alert(err+" decription");
	}
	setInterval(drawScene,35);
	
}

function clear(){
	  ctx.clearRect(0,0,ctx.canvas.width,ctx.canvas.height); //Erasing the Canvas
}

function clearColor(){
	  ctx.fillRect(0,0,ctx.canvas.width,ctx.canvas.height); //Filling the Canvas
}

function hitToken(event){

var keyCode; //Hold keyCode
if(event == null) { //If event null
keyCode = window.event.keyCode; //Get keyCode using window.event
Window.event.preventDefault(); //Stop default action
} 
else { 
keyCode = event.keyCode; 
event.preventDefault(); 
} 
//alert(" You just pressed keycode "+keyCode);
var t1X =tweetInCloud[curTwInd].token1X;
var t1Y =tweetInCloud[curTwInd].token1Y;

var t2X =tweetInCloud[curTwInd].token2X;
var t2Y =tweetInCloud[curTwInd].token2Y;
var t1 =tweetInCloud[curTwInd].token1;
var t2 =tweetInCloud[curTwInd].token2;
var kCode=String.fromCharCode(keyCode).toLowerCase()
if(tarTwInd==-1)
{tarTwInd=curTwInd}
if(curTwInd==tarTwInd)
{
var a=targetToken.length
if(a==0)
{
//alert(kCode + t1[0]+ " t"+targetToken);
	if(kCode==t1[0])
	{
		targetToken=t1;
		tarToken=0;
		bulletArray.push(new Bullet(ctx.canvas.width/2-3, ctx.canvas.height-95, t1X,t1Y,kCode,curTwInd,0,tarToken));
		curTarInd++;
		nbullets++;

	}
	else if((kCode==t2[0]))
	{
		targetToken=t2;
		tarToken=1;
		bulletArray.push(new Bullet(ctx.canvas.width/2-3, ctx.canvas.height-95, t2X,t2Y,kCode,curTwInd,0,tarToken));
		curTarInd++;
		nbullets++;
	}
}
else if((curTarInd<a)&&(kCode==targetToken[curTarInd])){
	if(curTarInd==a-1){
	if(tarToken==0)
	{bulletArray.push(new Bullet(ctx.canvas.width/2-3, ctx.canvas.height-95, t1X,t1Y,kCode,curTwInd,1,tarToken));}
	else if(tarToken==1)
	{bulletArray.push(new Bullet(ctx.canvas.width/2-3, ctx.canvas.height-95, t2X,t2Y,kCode,curTwInd,1,tarToken));}
	}
	else{
	if(tarToken==0)
	{bulletArray.push(new Bullet(ctx.canvas.width/2-3, ctx.canvas.height-95, t1X,t1Y,kCode,curTwInd,0,tarToken));}
	else if(tarToken==1)
	{bulletArray.push(new Bullet(ctx.canvas.width/2-3, ctx.canvas.height-95, t2X,t2Y,kCode,curTwInd,0,tarToken));}
	}
	curTarInd++;
	nbullets++;
	
}
//		bulletArray.push(new Bullet(ctx.canvas.width/2-3, ctx.canvas.height-95, t1X,t1Y,""));
//		nbullets++;
}
}

function drawScene()
{
        ctx.drawImage(backgroundImage, 0, 0, 800,500,0,0, ctx.canvas.width, ctx.canvas.height);
        ctx.globalAlpha = 1;
	ctx.drawImage(shootingObject, 0, 0, 45,48 ,ctx.canvas.width/2-20, ctx.canvas.height-80,45,48);
	//try{
	tweetFall();
	//}
	/*catch(err)
	{	alert(err);
	}*/
	window.addEventListener('keydown',hitToken,false);
	bullets();
	// Moving through the color array
	if (activeColor.fadeTo(colors[nextColorIndex])) {
	activeColor = colors[nextColorIndex++];
	if (nextColorIndex >= colors.length) {
		nextColorIndex = 0;
	}
    }
	
	//Opacity for the background
	ctx.globalAlpha = 0.8;
    
        ctx.fillStyle = 'rgb(' + activeColor.getRGB() + ')';	
	clearColor();
	
	ctx.save(); // Rotation is being always performed about centre. Therefore we save state before rotation and restore it later.
	ctx.globalAlpha = 0.3; //opacity for bars
	//translate and rotate the canvas
        ctx.translate(ctx.canvas.width / 2, ctx.canvas.height / 2);
	ctx.rotate(angle += angleAdjust);
	//draw bars and update coordinates for next time.
	//bars();
	
	ctx.restore();//restore the canvas to original position.
}

function bars(){

    

for (var i = topOffset; i < ctx.canvas.height + 600; i += (BAR_HEIGHT * 2)) {
	//still hv to decide width for rotation.. right now (widht/2+200)<->(600).
	//vertical drawing is (300)<->(300) the screen area.
	ctx.fillRect(0 - (ctx.canvas.width / 2) - 200,i - (ctx.canvas.height / 2) ,ctx.canvas.width + 600, BAR_HEIGHT );
}
    //update the angle of rotation
	if (angle > MAX_ANGLE || angle < 0 - MAX_ANGLE) {
		angleAdjust = 0 - angleAdjust;
	}

topOffset -= BAR_SPEED;
if (topOffset + BAR_HEIGHT * 2 + 300 < 0) {
	topOffset += BAR_HEIGHT * 2;
}
}

function bullets(){
var tempLength=bulletArray.length;
var tempflag=0;
var tempInd=-1;
var t1X =(tweetInCloud[curTwInd].token1X);
var t1Y =(tweetInCloud[curTwInd].token1Y);

var t2X =(tweetInCloud[curTwInd].token2X);
var t2Y =(tweetInCloud[curTwInd].token2Y);
var toX=t1X;
var toY=t1Y;
var cldShiftY=cloudShiftY1;
var cldShiftX=cloudShiftX1;

var tintin=(tweetInCloud[curTwInd].tweetId);

for(var j=initNbullet;j<tempLength;j++)
{
	ctx.drawImage(bulletImg, 0, 0, 300,300 ,bulletArray[j].x,bulletArray[j].y,15,15);
	bulletArray[j].y+=bulletArray[j].yinc;
	bulletArray[j].x+=bulletArray[j].xinc;

	if(bulletArray[j].toId==0){toX=t1X;toY=t1Y;cldShiftY=cloudShiftY1;cldShiftX=cloudShiftX1;}
	else if(bulletArray[j].toId==1){toX=t2X;toY=t2Y;cldShiftY=cloudShiftY2;cldShiftX=cloudShiftX2;}

	if(bulletArray[j].tInd==curTwInd)
	if(((bulletArray[j].y<=(toY+cldShiftY+1))&&(bulletArray[j].y>=(toY+cldShiftY-1)))||((bulletArray[j].x<=(toX+cldShiftX+1))&&(bulletArray[j].x>=(toX+cldShiftX-1))))  // To-Do Add code for collision Detection
	{
            var ko=tweetInCloud.length;
	    tempflag=1;
	    tempInd=(curTwInd);
            var tfin=bulletArray[j].fin;
	    var tToId=bulletArray[j].toId;
	    bulletArray.splice(j,1); // Probably add link list here or use two indexes to refer starting and beginning.
            tempLength=bulletArray.length;
            nbullets--;		
            if(ko>0){

               //alert("id= "+tToId);
		if(tfin==1)
		{
		getTweet(tintin,tToId);
                tweetInCloud.splice(tempInd,1);
		targetToken="";
		curTarInd=0;
		tarTwInd=-1;
    		cloudShiftY1=0;
    		cloudShiftX1=0;
    		cloudShiftY2=0;
    		cloudShiftX2=0;
		if(curTwInd>=ko-1){
    		curTwInd=0;
                }
		break;
		}
             }
             if(ko==1){
             alert("gameover");
	     }
	    
	     
	}
}

}


function Bullet(x,y,targetX,targetY,key,tInd,fin,toId){
this.x=x;
this.y=y;
this.targetX=targetX;
this.targetY=targetY;
this.key=key;
this.tInd=tInd;
this.fin=fin;
this.toId=toId;
var inc=incForTarget(x,y,targetX,targetY);
this.xinc=inc.x;
this.yinc=inc.y;
//console.log(key+" "+tInd+" "+finish);
}

function tweetCloud(tweetId,tweetTxt,token1,token2,tweetTxtX,tweetTxtY,token1X,token1Y,token2X,token2Y){
this.tweetId=tweetId;
this.tweetTxt=tweetTxt;
this.token1=token1;
this.token2=token2;
this.tweetTxtX=tweetTxtX;
this.tweetTxtY=tweetTxtY;
this.token1X=token1X;
this.token1Y=token1Y;
this.token2X=token2X;
this.token2Y=token2Y;

var inc=incForTarget(token1X,token1Y,ctx.canvas.width/2-10, ctx.canvas.height-95);

this.xinc1=inc.x;
this.yinc1=inc.y;

var inc=incForTarget(token2X,token2Y,ctx.canvas.width/2+10, ctx.canvas.height-95);

this.xinc2=inc.x;
this.yinc2=inc.y;

}

function incForTarget(x,y,targetX,targetY){

var dy=(targetY-y);
var dx=(targetX-x);
var steps=0;
var xinc=0;
var yinc=0;
if(Math.abs(dy)>Math.abs(dx))
{
	steps=Math.abs(dx);
}
else
{
	steps=Math.abs(dy);
}


xinc=dx/steps;
yinc=dy/steps;

return {x:xinc,y:yinc};
}

function tweetFall(){

var tX =tweetInCloud[curTwInd].tweetTxtX;
var tY =tweetInCloud[curTwInd].tweetTxtY;
var t1X =tweetInCloud[curTwInd].token1X;
var t1Y =tweetInCloud[curTwInd].token1Y;
var t2X =tweetInCloud[curTwInd].token2X;
var t2Y =tweetInCloud[curTwInd].token2Y;
var xinc1 =tweetInCloud[curTwInd].xinc1;
var yinc1 =tweetInCloud[curTwInd].yinc1;
var xinc2 =tweetInCloud[curTwInd].xinc2;
var yinc2 =tweetInCloud[curTwInd].yinc2;
var a=0;

    ctx.fillText(tweetInCloud[curTwInd].tweetTxt,tX,tY+cloudShiftY1)
    ctx.fillText(tweetInCloud[curTwInd].token1,t1X+cloudShiftX1,t1Y+cloudShiftY1)  
    ctx.fillText(tweetInCloud[curTwInd].token2,t2X+cloudShiftX2,t2Y+cloudShiftY2) 


    //Update Tweet Position
    cloudShiftY1+=yinc1;
    cloudShiftX1+=xinc1;


    cloudShiftY2+=yinc2;
    cloudShiftX2+=xinc2;

    if((cloudShiftY1>=300)||(cloudShiftX1>=300)){
    cloudShiftY1=0;
    cloudShiftX1=0;
    cloudShiftY2=0;
    cloudShiftX2=0;

    curTwInd++;
    curTarInd=0;
    targetToken="";
    tarTwInd=-1;
    a=tweetInCloud.length;
    if(curTwInd>=a)
    {curTwInd=0;
    }
    }

}

function Color(r,g,b) {
	this.r = r;
	this.g = g;
	this.b = b;
 
	this.step = COLOR_STEP;

	this.fadeTo = function(color) {
		this.r = this.r + ((color.r - this.r) * this.step);
		this.g = this.g + ((color.g - this.g) * this.step);
		this.b = this.b + ((color.b - this.b) * this.step);
 
		this.step += COLOR_STEP;
 
		if (this.r == color.r &&
				this.g == color.g &&
				this.b == color.b) {
 
			this.step = COLOR_STEP;
			return true;
		}
		return false;
	}
 
	this.getRGB = function() {
		return Math.round(this.r) + "," +
				Math.round(this.g) + "," +
				Math.round(this.b);
	}
}

function getTweet(tweetId, cat){

    var xmlhttp;
    if ((tweetId=="") || (cat == -1)) //Check if they are empty
      {
          //required action

          return;
      }
    if (window.XMLHttpRequest)
      { // code for IE7+, Firefox, Chrome, Opera, Safari
          xmlhttp=new XMLHttpRequest();
      }
    else
      { // code for IE6, IE5
          xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
      }
    xmlhttp.onreadystatechange=function()
      {
      if (xmlhttp.readyState==4 && xmlhttp.status==200)
        {
        document.getElementById("txtHint").innerHTML=xmlhttp.responseText;
        }
      }
try{

    xmlhttp.open("GET","/pt?tweetId=" + String(tweetId) + "&cat=" + String(cat),true);
//console.log("here");
}
catch(err)
{
alert(err);
}

    xmlhttp.send();
}


</script>
</head>

<body onLoad=init()>
	 <div id="backgroundHolder">
	 	 <canvas id="backgroundCanvas" width="600" height="400"></canvas>
	 </div>
	 <div id="realbody">
	 	 <!-- Content -->
	 </div>
</body>

</html>
